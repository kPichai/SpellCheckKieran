Name: Kieran Pichai

| Date     |       Time        |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      Update |
|:---------|:-----------------:|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------:|
| Sept. 23 |  9:35am - 9:55am  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               In this initial thought process I talked to some class mates about some ideas for the process we might implement on this program. Initially we considered things like linear search and binary search but ultimately decided that a map would be the most efficient way of sorting out this problem. However, what me and tony discussed was one main problem: how to assign each string to a unique value in a map. This would have to involve some sort of function that converts strings into unique ints. |
| Sept. 24 |  1:50pm - 2:25pm  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         In this section, I continued to think about a map and came up with an idea that would use a hashmap. Essentially what a hashmap does is create a key/item relationship in which if we created a hashmap that aligns a string with an int, we could use the string to get check if its in the dictionary, an O(1) lookup like a map. |
| Sept. 25 | 10:15pm - 10:45pm |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          In this scenario I actually tried to code a hash function using prime numbers, as apparently that increases the distribution of strings across ints and decreases the probability of overlap. However, my code didn't work and runs into int overflow issues and also issues with using the indices of the map. I'm going to try to fix this on my next iteration. |
| Sept. 26 | 12:45pm - 1:15pm  |                                                                                                                                                                                                                                                       I talked to tony about using a hash map and talked to Mr. Blick on how to implement one. My approach utilizes a mathematical method called hashString (not from the hash library, but one i coded) that uses prime numbers and the ascii values of a string to hash it into a unique code. The issue with this code is that it overflows even long ints, super space inefficient. If I use this method to hash 140000 element long array in which my hash maps would be essentially 1000000000 long and storing longs, then I'd be using gigabytes of data just to store this map (extremely space inefficient but very time efficient). As it is only O(n) to set up the map and O(v) to check if something is in the dictionary (if v = length of the string we are searching for). |
| Sept. 26 |  1:15pm - 1:45pm  | I then started discussing new solutions with the class. Me and Tony talked about a algorithm which turns the dictionary into a tree. This essentially works by taking each string in the dictionary letter by letter and making a tree that increases in size, however the trick to this tree is that it would remove any edges that lead to combinations of chars that don't create words. Essentially, instead of going to A -> ap -> it would go from A straight to Ape. This increases the efficiency of searching for a word, however the inital setup time is very computationally heavy (the advantage is that to find a word it'll be O(v) where v = number of chars in the string we are searching for). I then started thinking of another idea which utilizes a map of map, this is similar to my initial idea but much MUCH more space efficient. Essentially there is a map of chars (1-26 letters in the alphabet) then it continues down in levels until you make words. Theoretically this would also have an O(v) runtime. |
| Sept. 29 |  9:10pm - 9:40pm  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             In this iteration I fully coded my attempt at this problem but am running into index out of bounds errors, integer overflow errors, all due to my hash function. I've tried reducing the size of the numbers my hash function generates but despite this it still generates out of bounds numbers. I'll need to either further optimize this function or rethink my data structure that i'm using. I also switched from a string array to a boolean array as it should be more space efficient. |
| Oct. 1   |  10:45 - 11:30pm  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               During this session I coded the basis and recursive methods for a trie as well as coding the Node and Trie classes themselves. Within the Trie and the Node I have an insert and search algorithm that recursively go through the different levels of the trie until it either inserts the word or fails to find the word. I similarly implemented easy getters and setters in my Node class. My next steps are to actually initialize the trie and insert all the dictionary values into it. |
| Oct. 2   |  9:35am - 9:55am  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            During this section of class I worked some more on my Trie class as well as my SpellCheck class, actually implementing the code that would return a final array. However I ran into many null pointer exception errors. I tried to fix these and my code didn't work. Upon testing my recursive methods (which are now commented) I realized a few issues with how I was accessing the next array / map before i had checked if it even existed. |
| Oct. 2   |  8:45pm - 9:15pm  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           During this iteration I commented out my recursive methods which confused me and instead focused on writing simple for loops. This seemed to work much much better however still ran into null pointer issues. To be honest, this took a while to debug and eventually started working. However when running my array lengths were wildly different than the expected list lengths, this had meant something was wrong with either my insert or search algorithm. |
| Oct 2.   |  9:20pm - 9:50pm  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 Upon thinking about the issue above I realized a logic mistake, I initially passed in a node[] as an argument into my functions but realized I should just be passing in a node (as a node contains the nextSet array). Once I fixed this issue my numbers (and efficiency as well for some reason) improved drastically; despite this, my code still doesn't calculate the right number of incorrect elements in the text. |