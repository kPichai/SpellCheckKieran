Name: Kieran Pichai

| Date     |       Time        |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      Update |
|:---------|:-----------------:|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------:|
| Sept. 23 |  9:35am - 9:55am  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               In this initial thought process I talked to some class mates about some ideas for the process we might implement on this program. Initially we considered things like linear search and binary search but ultimately decided that a map would be the most efficient way of sorting out this problem. However, what me and tony discussed was one main problem: how to assign each string to a unique value in a map. This would have to involve some sort of function that converts strings into unique ints. |
| Sept. 24 |  1:50pm - 2:25pm  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         In this section, I continued to think about a map and came up with an idea that would use a hashmap. Essentially what a hashmap does is create a key/item relationship in which if we created a hashmap that aligns a string with an int, we could use the string to get check if its in the dictionary, an O(1) lookup like a map. |
| Sept. 25 | 10:15pm - 10:45pm |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          In this scenario I actually tried to code a hash function using prime numbers, as apparently that increases the distribution of strings across ints and decreases the probability of overlap. However, my code didn't work and runs into int overflow issues and also issues with using the indices of the map. I'm going to try to fix this on my next iteration. |
| Sept. 26 | 12:45pm - 1:15pm  |                                                                                                                                                                                                                                                       I talked to tony about using a hash map and talked to Mr. Blick on how to implement one. My approach utilizes a mathematical method called hashString (not from the hash library, but one i coded) that uses prime numbers and the ascii values of a string to hash it into a unique code. The issue with this code is that it overflows even long ints, super space inefficient. If I use this method to hash 140000 element long array in which my hash maps would be essentially 1000000000 long and storing longs, then I'd be using gigabytes of data just to store this map (extremely space inefficient but very time efficient). As it is only O(n) to set up the map and O(v) to check if something is in the dictionary (if v = length of the string we are searching for). |
| Sept. 26 |  1:15pm - 1:45pm  | I then started discussing new solutions with the class. Me and Tony talked about a algorithm which turns the dictionary into a tree. This essentially works by taking each string in the dictionary letter by letter and making a tree that increases in size, however the trick to this tree is that it would remove any edges that lead to combinations of chars that don't create words. Essentially, instead of going to A -> ap -> it would go from A straight to Ape. This increases the efficiency of searching for a word, however the inital setup time is very computationally heavy (the advantage is that to find a word it'll be O(v) where v = number of chars in the string we are searching for). I then started thinking of another idea which utilizes a map of map, this is similar to my initial idea but much MUCH more space efficient. Essentially there is a map of chars (1-26 letters in the alphabet) then it continues down in levels until you make words. Theoretically this would also have an O(v) runtime. |
| Sept. 29 |  9:10pm - 9:40pm  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             In this iteration I fully coded my attempt at this problem but am running into index out of bounds errors, integer overflow errors, all due to my hash function. I've tried reducing the size of the numbers my hash function generates but despite this it still generates out of bounds numbers. I'll need to either further optimize this function or rethink my data structure that i'm using. I also switched from a string array to a boolean array as it should be more space efficient. |
| Oct. 1   |  10:45 - 11:30pm  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               During this session I coded the basis and recursive methods for a trie as well as coding the Node and Trie classes themselves. Within the Trie and the Node I have an insert and search algorithm that recursively go through the different levels of the trie until it either inserts the word or fails to find the word. I similarly implemented easy getters and setters in my Node class. My next steps are to actually initialize the trie and insert all the dictionary values into it. |
| Oct. 2   |  9:35am - 9:55am  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            During this section of class I worked some more on my Trie class as well as my SpellCheck class, actually implementing the code that would return a final array. However I ran into many null pointer exception errors. I tried to fix these and my code didn't work. Upon testing my recursive methods (which are now commented) I realized a few issues with how I was accessing the next array / map before i had checked if it even existed. |
| Oct. 2   |  8:45pm - 9:15pm  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           During this iteration I commented out my recursive methods which confused me and instead focused on writing simple for loops. This seemed to work much much better however still ran into null pointer issues. To be honest, this took a while to debug and eventually started working. However when running my array lengths were wildly different than the expected list lengths, this had meant something was wrong with either my insert or search algorithm. |
| Oct. 2   |  9:20pm - 9:50pm  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 Upon thinking about the issue above I realized a logic mistake, I initially passed in a node[] as an argument into my functions but realized I should just be passing in a node (as a node contains the nextSet array). Once I fixed this issue my numbers (and efficiency as well for some reason) improved drastically; despite this, my code still doesn't calculate the right number of incorrect elements in the text. |
| Oct. 3   |  1:55pm - 2:30pm  |                                                                                                                                                                                                                                                                                                                                                                                                               I met with Mr. Blick to debug my code and we traced through some mental examples. A lot of the cleanup happened to be me passing in unnecessary variables and things I didn't really need. After reading through and being more concise in my search / insert methods I found some small logic errors in which i accessed the next node before checking if its null and having additional if statements that just added time to my algorithm without improving its functionality whatsoever. After I made these fixes my code still wasn't working then me and Mr. Blick realized that I was missing a single ! (not) symbol. |
| Oct. 3   |  2:30pm - 3:00pm  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    During this iteration I begin my code for my TST, in the meanwhile I also tested my code for the Trie and it worked. I also worked on slightly improving the efficiency of my trie by getting rid of un-needed variables or methods I had made that in the end only complicated my code. |
| Oct. 6   |  7:30pm - 8:00pm  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              During this iteration I coded my insert function of the TST. My logic followed the worksheets we did in class, moving through the different layers of the TST while inserting. |
| Oct. 6   |  8:00pm - 8:30pm  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           After going over my insert functino and seeing I had confused my root node with my curNode variables I then moved onto coding my search function. My logic was largely similar to that of my insert function as you move to the layer / node you want to check next at each iteration. I also coded some general set up that would test my search and insert functions on the test cases in the SpellCheck class. |
| Oct. 6   | 11:15pm - 11:45pm |                                                                                                                                                                                                                                                                                                                              During this final iteration (for oct. 6) I worked on testing my code and debugging it. Upon running my testing code I failed all the test cases and had many null pointer exceptions. I realized taht this was due to the ordering in which I called functions: I would check if the current node was null after I had tried to access its next element—leading to a null pointer as that next element didn't exist. Overall, I spent a while getting my code to run without errors (which it does not) and also implementing a misspelledTST to speed up efficiency and also so that we don't want to double count. My test cases still all fail but I feel that I am super close to a final working product. |
| Oct. 7   |  3:30pm - 4:00pm  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             During this time I traced my code using the debugger and tried to figure out what my errors were. I realized I wasn't actually changing the root node due to how I was dealing with my pointers and so I changed the function to be recursive and return a TSTnode each time; fixing that issue. Initially, my code had just been saying every single word isn't in the dictionary, now it was somewhat closer. |
| Oct. 7   |  4:00pm - 4:30pm  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               During this iteration I finished making my insert function recursive then further traced my searching function (inTST) changing my conditions on when I return true and false after realizing my searching algorithm would always just return false (hence the other part of my issue that my code was constantly returning that every single word wasn't in the dictionary). |